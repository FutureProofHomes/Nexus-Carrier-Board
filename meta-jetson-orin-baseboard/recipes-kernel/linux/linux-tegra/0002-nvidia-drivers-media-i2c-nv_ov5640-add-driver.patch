From 8ecc1ca295905371196f8b00c4e3770f21c3ba7c Mon Sep 17 00:00:00 2001
From: Roman Dobrodii <rdobrodii@antmicro.com>
Date: Wed, 15 Mar 2023 18:39:33 +0100
Subject: [PATCH 2/8] nvidia/drivers/media/i2c/nv_ov5640: add driver

Cherry-picked from Jetson Nano Baseboard with minor fixes.

Signed-off-by: Roman Dobrodii <rdobrodii@antmicro.com>
---
 nvidia/drivers/media/i2c/Kconfig            |  10 +
 nvidia/drivers/media/i2c/Makefile           |   1 +
 nvidia/drivers/media/i2c/nv_ov5640.c        | 570 ++++++++++++++++
 nvidia/drivers/media/i2c/ov5640_mode_tbls.h | 694 ++++++++++++++++++++
 nvidia/include/media/ov5640.h               | 109 +++
 nvidia/include/uapi/media/ov5640.h          |  93 +++
 6 files changed, 1477 insertions(+)
 create mode 100644 nvidia/drivers/media/i2c/nv_ov5640.c
 create mode 100644 nvidia/drivers/media/i2c/ov5640_mode_tbls.h
 create mode 100644 nvidia/include/media/ov5640.h
 create mode 100644 nvidia/include/uapi/media/ov5640.h

diff --git a/nvidia/drivers/media/i2c/Kconfig b/nvidia/drivers/media/i2c/Kconfig
index 0592973a864e..e2671b4b512f 100644
--- a/nvidia/drivers/media/i2c/Kconfig
+++ b/nvidia/drivers/media/i2c/Kconfig
@@ -79,6 +79,16 @@ config NV_VIDEO_LC898212
 	  To compile this driver as a module, choose M here: the module
 	  will be called lc898212.
 
+config NV_VIDEO_OV5640
+	tristate "OV5640 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This is an NVidia-specific Video4Linux2 sensor-level driver for
+	  the OmniVision OV5640 camera.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called ov5640.
+
 config NV_VIDEO_OV5693
 	tristate "OV5693 camera sensor support"
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
diff --git a/nvidia/drivers/media/i2c/Makefile b/nvidia/drivers/media/i2c/Makefile
index f8f6c3ba07d7..b5410c2f23a2 100644
--- a/nvidia/drivers/media/i2c/Makefile
+++ b/nvidia/drivers/media/i2c/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_NV_VIDEO_IMX268) += nv_imx268.o
 obj-$(CONFIG_NV_VIDEO_IMX274) += nv_imx274.o
 obj-$(CONFIG_NV_VIDEO_IMX318) += nv_imx318.o
 obj-$(CONFIG_NV_VIDEO_LC898212) += nv_lc898212.o
+obj-$(CONFIG_NV_VIDEO_OV5640) += nv_ov5640.o
 obj-$(CONFIG_NV_VIDEO_OV5693) += nv_ov5693.o
 obj-$(CONFIG_NV_VIDEO_OV9281) += nv_ov9281.o
 obj-$(CONFIG_NV_VIDEO_OV10823) += nv_ov10823.o
diff --git a/nvidia/drivers/media/i2c/nv_ov5640.c b/nvidia/drivers/media/i2c/nv_ov5640.c
new file mode 100644
index 000000000000..459bca015841
--- /dev/null
+++ b/nvidia/drivers/media/i2c/nv_ov5640.c
@@ -0,0 +1,570 @@
+/*
+ * ov5640.c - OV5640 sensor driver
+ *
+ * based on ov5693.c
+ *
+ * Copyright (c) 2013-2017, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2023, Antmicro Ltd.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <media/camera_common.h>
+#include <media/ov5640.h>
+
+#include "../platform/tegra/camera/camera_gpio.h"
+
+#include "ov5640_mode_tbls.h"
+
+#define OV5640_DEFAULT_LINE_LENGTH	(0x09C4)
+#define OV5640_DEFAULT_PIXEL_CLOCK	(160)
+#define OV5640_DEFAULT_MODE	OV5640_MODE_1920x1080
+#define OV5640_DEFAULT_WIDTH	1920
+#define OV5640_DEFAULT_HEIGHT	1080
+#define OV5640_DEFAULT_DATAFMT	MEDIA_BUS_FMT_UYVY8_2X8
+#define OV5640_DEFAULT_CLK_FREQ	24000000
+
+struct ov5640 {
+	struct camera_common_power_rail	power;
+	int				numctrls;
+	struct v4l2_ctrl_handler	ctrl_handler;
+	struct i2c_client		*i2c_client;
+	struct v4l2_subdev		*subdev;
+	struct media_pad		pad;
+
+	int				reg_offset;
+
+	s32				group_hold_prev;
+	u32				frame_length;
+	bool				group_hold_en;
+	struct regmap			*regmap;
+	struct camera_common_data	*s_data;
+	struct camera_common_pdata	*pdata;
+	struct v4l2_ctrl		*ctrls[];
+};
+
+static struct regmap_config ov5640_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+};
+
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+	{
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+};
+
+static int test_mode;
+module_param(test_mode, int, 0644);
+
+static inline int ov5640_read_reg(struct camera_common_data *s_data,
+				u16 addr, u8 *val)
+{
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(priv->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+
+	return err;
+}
+
+static int ov5640_write_reg(struct camera_common_data *s_data, u16 addr, u8 val)
+{
+	int err = 0;
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		pr_err("%s:i2c write failed, %x = %x\n",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int ov5640_write_table(struct ov5640 *priv,
+			      const ov5640_reg table[])
+{
+        int err = 0;
+	err = regmap_util_write_table_8(priv->regmap,
+				table_mode_init,
+				NULL, 0,
+				OV5640_TABLE_WAIT_MS,
+				OV5640_TABLE_END);
+	if (err) return err;
+
+	err = regmap_util_write_table_8(priv->regmap,
+					 table,
+					 NULL, 0,
+					 OV5640_TABLE_WAIT_MS,
+					 OV5640_TABLE_END);
+	if (err) return err;
+	err = regmap_util_write_table_8(priv->regmap,
+				table_common_end,
+				NULL, 0,
+				OV5640_TABLE_WAIT_MS,
+				OV5640_TABLE_END);
+
+	return err;
+}
+
+
+static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;	
+	int err;
+	u32 frame_time;
+	u8 val;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	if (!enable) {
+		/*
+		 * Wait for one frame to make sure sensor is set to
+		 * software standby in V-blank
+		 *
+		 * frame_time = frame length rows * Tline
+		 * Tline = line length / pixel clock (in MHz)
+		 */
+		frame_time = priv->frame_length *
+			OV5640_DEFAULT_LINE_LENGTH / OV5640_DEFAULT_PIXEL_CLOCK;
+
+		usleep_range(frame_time, frame_time + 1000);
+		return 0;
+	}
+	dev_dbg(&client->dev, "s_data->mode %d----------------\n", s_data->mode);
+	err = ov5640_write_table(priv, mode_table[s_data->mode]);
+	if (err)
+		goto exit;
+
+
+ 	if (priv->pdata->v_flip) {
+		ov5640_read_reg(priv->s_data, OV5640_TIMING_REG20, &val);
+		ov5640_write_reg(priv->s_data, OV5640_TIMING_REG20,
+				 val | VERTICAL_FLIP);
+	}
+	if (priv->pdata->h_mirror) {
+		ov5640_read_reg(priv->s_data, OV5640_TIMING_REG21, &val);
+ 		ov5640_write_reg(priv->s_data, OV5640_TIMING_REG21,
+				 val | HORIZONTAL_MIRROR_MASK);
+	} else {
+		ov5640_read_reg(priv->s_data, OV5640_TIMING_REG21, &val);
+		ov5640_write_reg(priv->s_data, OV5640_TIMING_REG21,
+				 val & (~HORIZONTAL_MIRROR_MASK));
+	}
+	
+	if (test_mode) {
+	dev_dbg(&client->dev, "%s-- test_mode----------------\n", __func__);
+		err = ov5640_write_table(priv,
+			mode_table[OV5640_MODE_TEST_PATTERN]);
+}
+	dev_dbg(&client->dev, "%s--\n", __func__);
+	return 0;
+exit:
+	dev_dbg(&client->dev, "%s: error setting stream\n", __func__);
+	return err;
+}
+
+static int ov5640_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	*status = pw->state == SWITCH_ON;
+	return 0;
+}
+
+static uint16_t cam_mbus_formats[] = {
+
+	MEDIA_BUS_FMT_UYVY8_2X8,
+};
+
+static int cam_enum_mbus_code(struct v4l2_subdev *sd,
+
+	struct v4l2_subdev_pad_config *cfg,
+	struct v4l2_subdev_mbus_code_enum *code)
+
+	{
+		if (code->index >= ARRAY_SIZE(cam_mbus_formats))
+			return -EINVAL;
+		code->code = cam_mbus_formats[code->index];
+		return 0;
+}
+
+
+static struct v4l2_subdev_video_ops ov5640_subdev_video_ops = {
+	.s_stream	= ov5640_s_stream,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0)
+	.g_mbus_config	= camera_common_g_mbus_config,
+#endif
+	.g_input_status = ov5640_g_input_status,
+};
+
+static struct v4l2_subdev_core_ops ov5640_subdev_core_ops = {
+	.s_power	= camera_common_s_power,
+};
+
+static int ov5640_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static int ov5640_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	int ret;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+
+	return ret;
+}
+
+static struct v4l2_subdev_pad_ops ov5640_subdev_pad_ops = {
+	.set_fmt = ov5640_set_fmt,
+	.get_fmt = ov5640_get_fmt,
+	.enum_mbus_code = cam_enum_mbus_code,
+	.enum_frame_size	= camera_common_enum_framesizes,
+	.enum_frame_interval	= camera_common_enum_frameintervals,
+};
+
+static struct v4l2_subdev_ops ov5640_subdev_ops = {
+	.core	= &ov5640_subdev_core_ops,
+	.video	= &ov5640_subdev_video_ops,
+	.pad	= &ov5640_subdev_pad_ops,
+};
+
+static struct of_device_id ov5640_of_match[] = {
+	{ .compatible = "ovti,ov5640", },
+	{ },
+};
+
+static struct camera_common_sensor_ops ov5640_common_ops = {
+	.write_reg = ov5640_write_reg,
+	.read_reg = ov5640_read_reg,
+};
+
+
+static int ov5640_ctrls_init(struct ov5640 *priv)
+{
+	struct i2c_client *client = priv->i2c_client;	
+	struct v4l2_ctrl *ctrl;
+	int numctrls;
+	int err;
+	int i;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	numctrls = ARRAY_SIZE(ctrl_config_list);
+	v4l2_ctrl_handler_init(&priv->ctrl_handler, numctrls);
+
+	for (i = 0; i < numctrls; i++) {
+		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+			&ctrl_config_list[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(&client->dev, "Failed to init %s ctrl\n",
+				ctrl_config_list[i].name);
+			continue;
+		}
+
+		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
+				ctrl_config_list[i].max + 1, GFP_KERNEL);
+			if (!ctrl->p_new.p_char)
+				return -ENOMEM;
+		}
+		priv->ctrls[i] = ctrl;
+	}
+
+	priv->numctrls = numctrls;
+	priv->subdev->ctrl_handler = &priv->ctrl_handler;
+	if (priv->ctrl_handler.error) {
+		dev_err(&client->dev, "Error %d adding controls\n",
+			priv->ctrl_handler.error);
+		err = priv->ctrl_handler.error;
+		goto error;
+	}
+
+	err = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d setting default controls\n", err);
+		goto error;
+	}
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	return err;
+}
+
+MODULE_DEVICE_TABLE(of, ov5640_of_match);
+
+static struct camera_common_pdata *ov5640_parse_dt(struct i2c_client *client)
+{
+	struct device_node *node = client->dev.of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	//int err;
+	struct camera_common_pdata *ret = NULL;
+
+	if (!node)
+		return NULL;
+
+	match = of_match_device(ov5640_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(&client->dev,
+			   sizeof(*board_priv_pdata), GFP_KERNEL);
+	if (!board_priv_pdata)
+		return NULL;
+
+	//err = camera_common_parse_clocks(&client->dev, board_priv_pdata);
+	//if (err) {
+	//	dev_err(&client->dev, "Failed to find clocks\n");
+	//	goto error;
+	//}
+
+	board_priv_pdata->v_flip= of_property_read_bool(node, "vertical-flip");
+	board_priv_pdata->h_mirror = of_property_read_bool(node,
+							 "horizontal-mirror");
+	return board_priv_pdata;
+
+	//error:
+	//devm_kfree(&client->dev, board_priv_pdata);
+	return ret;
+}
+
+static int ov5640_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops ov5640_subdev_internal_ops = {
+	.open = ov5640_open,
+};
+
+static const struct media_entity_operations ov5640_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int ov5640_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct camera_common_data *common_data;
+	struct device_node *node = client->dev.of_node;
+	struct ov5640 *priv;
+	char debugfs_name[10];
+	int err;
+        u8 chip_id_hi, chip_id_lo;
+        u16 chip_id;
+
+	pr_info("[OV5640]: probing v4l2 sensor.\n");
+
+	if (!IS_ENABLED(CONFIG_OF) || !node)
+		return -EINVAL;
+
+	common_data = devm_kzalloc(&client->dev,
+			    sizeof(struct camera_common_data), GFP_KERNEL);
+	if (!common_data)
+		return -ENOMEM;
+
+	priv = devm_kzalloc(&client->dev,
+			    sizeof(struct ov5640) + sizeof(struct v4l2_ctrl *) *
+			    ARRAY_SIZE(ctrl_config_list),
+			    GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->regmap = devm_regmap_init_i2c(client, &ov5640_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	priv->pdata = ov5640_parse_dt(client);
+	if (PTR_ERR(priv->pdata) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	if (!priv->pdata) {
+		dev_err(&client->dev, "unable to get platform data\n");
+		return -EFAULT;
+	}
+
+	common_data->ops		= &ov5640_common_ops;
+	common_data->ctrl_handler	= &priv->ctrl_handler;
+	common_data->dev		= &client->dev;
+	common_data->frmfmt		= ov5640_frmfmt;
+	common_data->colorfmt		= camera_common_find_datafmt(
+					  OV5640_DEFAULT_DATAFMT);
+	common_data->power		= &priv->power;
+	common_data->ctrls		= priv->ctrls;
+	common_data->priv		= (void *)priv;
+	common_data->numctrls		= ARRAY_SIZE(ctrl_config_list);
+	common_data->numfmts		= ARRAY_SIZE(ov5640_frmfmt);
+	common_data->def_mode		= OV5640_DEFAULT_MODE;
+	common_data->def_width		= OV5640_DEFAULT_WIDTH;
+	common_data->def_height		= OV5640_DEFAULT_HEIGHT;
+	common_data->fmt_width		= common_data->def_width;
+	common_data->fmt_height		= common_data->def_height;
+	common_data->def_clk_freq	= OV5640_DEFAULT_CLK_FREQ;
+
+	priv->i2c_client = client;
+	priv->s_data			= common_data;
+	priv->subdev			= &common_data->subdev;
+	priv->subdev->dev		= &client->dev;
+	priv->s_data->dev		= &client->dev;
+
+	err = camera_common_initialize(common_data, "ov5640");
+	if (err) {
+		dev_err(&client->dev, "Failed to initialize ov5640.\n");
+		return err;
+	}
+
+	err = ov5640_read_reg(priv->s_data, 0x300A, &chip_id_hi);
+        if (err) {
+                dev_err(&client->dev, "Failure to read Chip ID (high byte)\n");
+                return err;
+        }
+
+        err = ov5640_read_reg(priv->s_data, 0x300B, &chip_id_lo);
+        if (err) {
+                dev_err(&client->dev, "Failure to read Chip ID (low byte)\n");
+                return err;
+        }
+
+        chip_id = (chip_id_hi << 8) | chip_id_lo;
+        if (chip_id != 0x5640) {
+                dev_err(&client->dev, "Chip ID: %x not supported!\n",
+                        chip_id);
+                err = -ENODEV;
+                return err;
+        }
+	
+	err = camera_common_parse_ports(&client->dev, common_data);
+	if (err) {
+		dev_err(&client->dev, "Failed to find port info\n");
+		return err;
+	}
+	sprintf(debugfs_name, "ov5640_%c", common_data->csi_port + 'a');
+	dev_dbg(&client->dev, "%s: name %s\n", __func__, debugfs_name);
+	camera_common_create_debugfs(common_data, debugfs_name);
+
+	v4l2_i2c_subdev_init(priv->subdev, client, &ov5640_subdev_ops);
+	
+	err = ov5640_ctrls_init(priv);
+	if (err)
+		return err;
+
+	priv->subdev->internal_ops = &ov5640_subdev_internal_ops;
+	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+			       V4L2_SUBDEV_FL_HAS_EVENTS;
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	priv->subdev->entity.ops = &ov5640_media_ops;
+	err = tegra_media_entity_init(&priv->subdev->entity, 1, &priv->pad, true, true);
+
+	if (err < 0) {
+		dev_err(&client->dev, "unable to init media entity\n");
+		return err;
+	}
+#endif
+
+	err = v4l2_async_register_subdev(priv->subdev);
+	if (err)
+		return err;
+
+	dev_dbg(&client->dev, "Detected OV5640 sensor\n");
+
+
+	return 0;
+}
+
+static int
+ov5640_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+
+	v4l2_async_unregister_subdev(priv->subdev);
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&priv->subdev->entity);
+#endif
+
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	camera_common_remove_debugfs(s_data);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov5640_id[] = {
+	{ "ov5640", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, ov5640_id);
+
+static struct i2c_driver ov5640_i2c_driver = {
+	.driver = {
+		.name = "ov5640",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(ov5640_of_match),
+	},
+	.probe = ov5640_probe,
+	.remove = ov5640_remove,
+	.id_table = ov5640_id,
+};
+
+module_i2c_driver(ov5640_i2c_driver);
+
+MODULE_DESCRIPTION("SoC Camera driver for Omnivision OV5640");
+MODULE_AUTHOR("David Wang <davidw@nvidia.com>");
+MODULE_LICENSE("GPL v2");
+
diff --git a/nvidia/drivers/media/i2c/ov5640_mode_tbls.h b/nvidia/drivers/media/i2c/ov5640_mode_tbls.h
new file mode 100644
index 000000000000..06369d8e8c41
--- /dev/null
+++ b/nvidia/drivers/media/i2c/ov5640_mode_tbls.h
@@ -0,0 +1,694 @@
+/*
+ * ov5640_mode_tbls.h - OV5640 sensor mode tables
+ *
+ * based on ov5693_mode_tlbs.h
+ * Copyright (c) 2015-2017, NVIDIA CORPORATION, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __OV5640_TABLES__
+#define __OV5640_TABLES__
+
+#include <media/camera_common.h>
+
+#define OV5640_TABLE_WAIT_MS	0
+#define OV5640_TABLE_END	1
+#define OV5640_MAX_RETRIES	3
+#define OV5640_WAIT_MS		10
+
+#define ov5640_reg struct reg_8
+
+/* System and IO Pad Control [0x3000 ~ 0x3052] */
+#define OV5640_SYSTEM_RESET_00    0x3000  /* default 0x30 -> all 0x00 */
+#define OV5640_SYSTEM_RESET_01    0x3001  /* default 0x08 */
+#define OV5640_SYSTEM_RESET_02    0x3002  /* default 0x1c */
+#define OV5640_SYSTEM_RESET_03    0x3003  /* default 0x00 */
+#define OV5640_SYSTEM_CLK_EN_00   0x3004  /* default 0xcf -> all 0xff */
+#define OV5640_SYSTEM_CLK_EN_01   0x3005  /* default 0xf7 */
+#define OV5640_SYSTEM_CLK_EN_02   0x3006  /* default 0xe3 -> all 0xc3 */
+#define OV5640_SYSTEM_CLK_EN_03   0x3007  /* default 0xff */
+#define OV5640_SYSTEM_CTRL        0x3008  /* default 0x02 all -> (0x82, 0x42, 0x02) */
+#define OV5640_CHIP_ID_H          0x300a  /* default 0x56 */
+#define OV5640_CHIP_ID_L          0x300b  /* default 0x40 */
+#define OV5640_SYSTEM_MIPI_CTRL   0x300e  /* default 0x58 -> all 0x45 */
+#define OV5640_IO_CTRL_01         0x3017  /* default 0x00 */
+#define OV5640_IO_CTRL_02         0x3018  /* default 0x00 */
+#define OV5640_SYSTEM_CTRL_2D     0x302d  /* default ---- -> all 0x60 !! */
+#define OV5640_SYSTEM_CTRL_2E     0x302e  /* default ---- -> all 0x08 !! */
+#define OV5640_SC_PLL_CTRL0       0x3034  /* default 0x1a -> all 0x18 MIPI_MODE */
+#define OV5640_SC_PLL_CTRL1       0x3035  /* default 0x11 -> 0x11 0x11 0x21 0x14 */
+#define OV5640_SC_PLL_CTRL2       0x3036  /* default 0x69 -> 0x7d 0x54 0x70 0x70 */ 
+#define OV5640_SC_PLL_CTRL3       0x3037  /* default 0x03 -> all 0x13 */
+#define OV5640_SC_PLL_CTRL5       0x3039  /* not use */
+
+#define SYSTEM_CTRL_SRST    0x80      /* Bit[7]: Software reset */
+#define SYSTEM_CTRL_PDOWN   0x40      /* Bit[6]: Software power down */
+#define MIPI_MODE_8BIT      0x08      /* Bit[3:0]: MIPI bit mode - 8-bit mode */
+#define MIPI_MODE_10BIT     0x0a      /* Bit[3:0]: MIPI bit mode - 10-bit mode */
+
+/* SCCB Control [0x3100 ~ 0x3108] */
+#define OV5640_SCCB_SYSTEM_CTRL   0x3103  /* default 0x00 -> all 0x03 */
+#define OV5640_SCCB_SCLK          0x3108  /* default 0x16 -> all 0x01 */
+
+/* VCM Control [0x3600 ~ 0x3606] */
+#define OV5640_VCM_DEBUG_MODE_0   0x3600  /* default ---- -> all 0x08 */
+#define OV5640_VCM_DEBUG_MODE_1   0x3601  /* default ---- -> all 0x33 */
+
+/* Timing Control [0x3800 ~ 0x3821] */
+#define OV5640_TIMING_HS_H        0x3800  /* default 0x00 -> 0x00 0x01 0x00 0x00 X_ADDR_ST */
+#define OV5640_TIMING_HS_L        0x3801  /* default 0x00 -> 0x00 0x50 0x00 0x00 */
+#define OV5640_TIMING_VS_H        0x3802  /* default 0x00 -> 0x00 0x01 0x00 0x00 Y_ADDR_ST */
+#define OV5640_TIMING_VS_L        0x3803  /* default 0x00 -> 0x00 0xaa 0x00 0x04 */
+#define OV5640_TIMING_HW_H        0x3804  /* default 0x0a -> 0x0a 0x08 0x0a 0x0a X_ADDR_END */
+#define OV5640_TIMING_HW_L        0x3805  /* default 0x3f -> 0x3f 0xef 0x3f 0x3f 2623 */
+#define OV5640_TIMING_VH_H        0x3806  /* default 0x07 -> 0x07 0x05 0x07 0x07 Y_ADDR_END */
+#define OV5640_TIMING_VH_L        0x3807  /* default 0x9f -> 0x9f 0xf9 0x9f 0x9b */
+#define OV5640_TIMING_DVPHO_H     0x3808  /* default 0x0a -> 0x0a 0x07 0x05 0x02  width[11:8]  */
+#define OV5640_TIMING_DVPHO_L     0x3809  /* default 0x20 -> 0x30 0x90 0x18 0x80  width[7:0]   */
+#define OV5640_TIMING_DVPVO_H     0x380a  /* default 0x07 -> 0x07 0x04 0x03 0x01  height[11:8] */
+#define OV5640_TIMING_DVPVO_L     0x380b  /* default 0x98 -> 0x9c 0x48 0xcc 0xe0  height[7:0]  */
+#define OV5640_TIMING_HTS_H       0x380c  /* default 0x0b -> 0x0b 0x09 0x07 0x07 */
+#define OV5640_TIMING_HTS_L       0x380d  /* default 0x1c -> 0x1c 0xc4 0x5e 0x68 */
+#define OV5640_TIMING_VTS_H       0x380e  /* default 0x07 -> 0x07 0x04 0x03 0x03 */
+#define OV5640_TIMING_VTS_L       0x380f  /* default 0xb0 -> 0xb0 0x60 0xde 0xd8 */
+#define OV5640_TIMING_HOFFSET_H   0x3810  /* default 0x00 */
+#define OV5640_TIMING_HOFFSET_L   0x3811  /* default 0x10 -> 0x08 0x08 0x06 0x10 */
+#define OV5640_TIMING_VOFFSET_H   0x3812  /* default 0x00 */
+#define OV5640_TIMING_VOFFSET_L   0x3813  /* default 0x04 -> 0x02 0x04 0x02 0x06 */
+#define OV5640_TIMING_X_INC       0x3814  /* default 0x11 -> 0x11 0x11 0x31 0x31 */
+#define OV5640_TIMING_Y_INC       0x3815  /* default 0x11 -> 0x11 0x11 0x31 0x31 */
+#define OV5640_TIMING_REG20       0x3820  /* default 0x40 -> 0x40 0x40 0x41 0x41  sensor vflip */
+#define OV5640_TIMING_REG21       0x3821  /* default 0x00 -> 0x06 0x06 0x07 0x07 */
+#define REG20_SENSOR_VFLIP     0x02
+#define REG20_SENSOR_ISP_FLIP  0x04
+#define REG21_BINNING_EN       0x01
+#define REG21_SENSOR_MIRROR    0x02
+#define REG21_ISP_MIRROR       0x04
+
+#define OV5640_ADDR_H(x)       ((x >> 8 ) & 0x0f)
+#define OV5640_ADDR_L(x)       (x & 0xff)
+#define OV5640_WIDTH_H(x)      ((x >> 8 ) & 0x0f)
+#define OV5640_WIDTH_L(x)      (x & 0xff)
+#define OV5640_HEIGHT_H(x)     ((x >> 8 ) & 0x0f)
+#define OV5640_HEIGHT_L(x)     (x & 0xff)
+#define OV5640_HTS_H(x)        ((x >> 8 ) & 0x1f)
+#define OV5640_HTS_L(x)        (x & 0xff)
+#define OV5640_VTS_H(x)        ((x >> 8 ) & 0xff)
+#define OV5640_VTS_L(x)        (x & 0xff)
+#define OV5640_H_OFFSET_H(x)   ((x >> 8 ) & 0x0F)
+#define OV5640_H_OFFSET_L(x)   (x & 0xff)
+#define OV5640_V_OFFSET_H(x)   ((x >> 8 ) & 0x03)
+#define OV5640_V_OFFSET_L(x)   (x & 0xff)
+
+/* AEC/AGC power down domain control [0x3A00 ~ 0x3A25] */
+#define OV5640_AEC_CTRL_0F        0x3a0f  /* default 0x78 -> all 0x30 */
+#define OV5640_AEC_CTRL_10        0x3a10  /* default 0x68 -> all 0x28 */
+#define OV5640_AEC_CTRL_11        0x3a11  /* default 0xd0 -> all 0x60 */
+#define OV5640_AEC_CTRL_1B        0x3a1b  /* default 0x78 -> all 0x30 */
+#define OV5640_AEC_CTRL_1E        0x3a1e  /* default 0x68 -> all 0x26 */
+#define OV5640_AEC_CTRL_1F        0x3a1f  /* default 0x40 -> all 0x14 */
+#define OV5640_AEC_MAX_EXPO60_H   0x3a02  /* default 0x3d -> 0x07 0x04 0x03 0x03 */
+#define OV5640_AEC_MAX_EXPO60_L   0x3a03  /* default 0x80 -> 0xb6 0x60 0xd8 0xd8 */
+#define OV5640_AEC_B50_STEP_H     0x3a08  /* default 0x01 */
+#define OV5640_AEC_B50_STEP_L     0x3a09  /* default 0x27 -> 0x27 0x50 0x27 0x27 */
+#define OV5640_AEC_B60_STEP_H     0x3a0a  /* default 0x00 -> 0x00 0x01 0x00 0x00 */
+#define OV5640_AEC_B60_STEP_L     0x3a0b  /* default 0xf6 -> 0xf6 0x18 0xf6 0xf6 */
+#define OV5640_AEC_CTRL_0D        0x3a0d  /* default 0x08 -> 0x06 0x03 0x03 0x03 */
+#define OV5640_AEC_CTRL_0E        0x3a0e  /* default 0x06 -> 0x06 0x04 0x04 0x04 */
+#define OV5640_AEC_CTRL_13        0x3a13  /* default 0x40 -> all 0x43 */
+#define OV5640_AEC_MAX_EXPO_H     0x3a14  /* default 0x0e -> 0x07 0x04 0x03 0x03 */
+#define OV5640_AEC_MAX_EXPO_L     0x3a15  /* default 0x40 -> 0xb0 0xd0 0xd8 0xd8 */
+#define OV5640_AEC_GAIN_CEILING_0 0x3a18  /* default 0x03 -> all 0x00 */
+#define OV5640_AEC_GAIN_CEILING_1 0x3a19  /* default 0xE0 -> all 0xf8 */
+
+/* 50/60Hz detector control [0x3C00 ~ 0x3C1E] */
+#define OV5640_5060_CTRL_01       0x3c01  /* default 0x00 -> all 0x34 */
+#define OV5640_5060_CTRL_04       0x3c04  /* default 0x20 -> all 0x28 */
+#define OV5640_5060_CTRL_05       0x3c05  /* default 0x70 -> all 0x98 */
+
+#define OV5640_5060_THRESHOLD_1_H 0x3c06  /* default 0x00 -> all 0x00 */
+#define OV5640_5060_THRESHOLD_1_L 0x3c07  /* default 0x00 -> all 0x07 0x07 0x07 0x07 0x08 */
+#define OV5640_5060_THRESHOLD_2_H 0x3c08  /* default 0x01 -> all 0x00 */
+#define OV5640_5060_THRESHOLD_2_L 0x3c09  /* default 0x2c -> all 0x1c */
+#define OV5640_5060_SAMPLE_NUM_H  0x3c0a  /* default 0x4e -> all 0x9c */
+#define OV5640_5060_SAMPLE_NUM_L  0x3c0b  /* default 0x1f -> all 0x40 */
+
+/* BLC Control [0x4000 ~ 0x4033] */
+#define OV5640_BLC_CTRL_01        0x4001  /* default 0x00 -> 0x02 */
+#define OV5640_BLC_CTRL_04        0x4004  /* default 0x08 -> 0x06 0x06 0x02 0x02 */
+
+/* MIPI control [0x4800 ~ 0x4837] */
+#define OV5640_MIPI_CTRL_00       0x4800  /* default 0x04 */
+#define OV5640_MIPI_CTRL_01       0x4801  /* not use */
+#define OV5640_MIPI_CTRL_05       0x4805  /* not use */
+#define OV5640_MIPI_PCLK_PERIOD   0x4837  /* default 0x10 -> 0x0a 0x0a 0x10 0x44 */
+
+/* Format Control [0x4300 ~ 0x430D] */
+#define FMT_CTRL_00               0x4300  /* default 0xF8 -> all 0x32 */
+
+/* Format Control */
+#define FMT_YUV422	 0x30
+/* Output sequence */
+#define OFMT_YUYV        0x00
+#define OFMT_YVYU        0x01
+#define OFMT_UYVY        0x02
+#define OFMT_VYUY        0x03
+
+/* ISP Control [0x5000 ~ 0x5063] */
+#define OV5640_ISP_CTRL_00        0x5000  /* default 0x06 -> all 0xa7 */
+#define OV5640_ISP_CTRL_01        0x5001  /* default 0x01 -> 0x83 0x83 0x83 0xa3 */
+#define OV5640_ISP_MUX_CTRL       0x501F  /* default 0x00 -> all 0x00 (000: ISP YUV422) */
+#define OV5640_ISP_DEBUG_25       0x5025  /* default ---- -> all 0x00 */
+#define OV5640_ISP_TEST           0x503D  /* default 0x00 */
+#define OV5640_ISP_DEBUG_3E       0x503E  /* default ---- */
+#define OV5640_ISP_DEBUG_46       0x5046  /* default ---- */
+
+#define ISP_SCALE_DIGITAL     0x80       /* Special digital effect */
+#define ISP_SCALE_EN          0x20       /* Scale enable */
+#define ISP_AUTO_BALANCE_EN   0x01       /* Auto white balance enable */
+#define ISP_COLOR_MATRIX_EN   0x02       /* Color matrix enable */
+#define ISP_TEST_EN           0x80
+#define ISP_TEST_00           0x00       /* 00: Standard eight color bar */
+#define ISP_TEST_01           0x01       /* 01: Gradual change at vertical mode 1 */
+#define ISP_TEST_10           0x02       /* 10: Gradual change at horizontal */
+#define ISP_TEST_11           0x03       /* 11: Gradual change at vertical mode 2 */
+#define ISP_TEST_TRANSPARENT  0x20       /* Transparent */
+#define ISP_TEST_ROLLING      0x40       /* Rolling */
+
+/* AWB Control [0x5180 ~ 0x51D0] */
+#define OV5640_AWB_CTRL_00        0x5180  /* default 0xff */
+#define OV5640_AWB_CTRL_01        0x5181  /* default 0x58 -> all 0xf2 */
+#define OV5640_AWB_CTRL_02        0x5182  /* default 0x11 -> all 0x00 */
+#define OV5640_AWB_CTRL_03        0x5183  /* default 0x90 -> all 0x14 */
+#define OV5640_AWB_CTRL_04        0x5184  /* default 0x25 */
+#define OV5640_AWB_CTRL_05        0x5185  /* default 0x24 */
+#define OV5640_AWB_CTRL_06        0x5186  /* default ---- -> all 0x09 */
+#define OV5640_AWB_CTRL_07        0x5187  /* default ---- -> all 0x09 */
+#define OV5640_AWB_CTRL_08        0x5188  /* default ---- -> all 0x09 */
+#define OV5640_AWB_CTRL_09        0x5189  /* default ---- -> all 0x75 */
+#define OV5640_AWB_CTRL_10        0x518a  /* default ---- -> all 0x54 */
+#define OV5640_AWB_CTRL_11        0x518b  /* default ---- -> all 0xe0 */
+#define OV5640_AWB_CTRL_12        0x518c  /* default ---- -> all 0xb2 */
+#define OV5640_AWB_CTRL_13        0x518d  /* default ---- -> all 0x42 */
+#define OV5640_AWB_CTRL_14        0x518e  /* default ---- -> all 0x3d */
+#define OV5640_AWB_CTRL_15        0x518f  /* default ---- -> all 0x56 */
+#define OV5640_AWB_CTRL_16        0x5190  /* default ---- -> all 0x46 */
+#define OV5640_AWB_CTRL_17        0x5191  /* default 0xff -> all 0xf8 */
+#define OV5640_AWB_CTRL_18        0x5192  /* default 0x00 -> all 0x04 */
+#define OV5640_AWB_CTRL_19        0x5193  /* default 0xf0 -> all 0x70 */
+#define OV5640_AWB_CTRL_20        0x5194  /* default 0xf0 */
+#define OV5640_AWB_CTRL_21        0x5195  /* default 0xf0 */
+#define OV5640_AWB_CTRL_22        0x5196  /* default 0x03 */
+#define OV5640_AWB_CTRL_23        0x5197  /* default 0x02 -> all 0x01 */
+#define OV5640_AWB_CTRL_24        0x5198  /* default ---- -> all 0x04 */
+#define OV5640_AWB_CTRL_25        0x5199  /* default ---- -> all 0x12 */
+#define OV5640_AWB_CTRL_26        0x519a  /* default ---- -> all 0x04 */
+#define OV5640_AWB_CTRL_27        0x519b  /* default ---- -> all 0x00 */
+#define OV5640_AWB_CTRL_28        0x519c  /* default ---- -> all 0x06 */
+#define OV5640_AWB_CTRL_29        0x519d  /* default ---- -> all 0x82 */
+#define OV5640_AWB_CTRL_30        0x519e  /* default 0x02 -> all 0x38 */
+
+/* CIP Control [0x5300 ~ 0x530F] */
+#define OV5640_CIP_SH_MT_THRES_1  0x5300  /* default 0x08 */
+#define OV5640_CIP_SH_MT_THRES_2  0x5301  /* default 0x48 -> all 0x30 */
+#define OV5640_CIP_SH_MT_OFFSET_1 0x5302  /* default 0x18 -> all 0x10 */
+#define OV5640_CIP_SH_MT_OFFSET_2 0x5303  /* default 0x0e -> all 0x00 */
+#define OV5640_CIP_DNS_THRES_1    0x5304  /* default 0x08 */
+#define OV5640_CIP_DNS_THRES_2    0x5305  /* default 0x48 -> all 0x30 */
+#define OV5640_CIP_DNS_OFFSET_1   0x5306  /* default 0x09 -> all 0x08 */
+#define OV5640_CIP_DNS_OFFSET_2   0x5307  /* default 0x16 */
+#define OV5640_CIP_SH_TH_THRES_1  0x5309  /* default 0x08 */
+#define OV5640_CIP_SH_TH_THRES_2  0x530a  /* default 0x48 -> all 0x30 */
+#define OV5640_CIP_SH_TH_OFFSET_1 0x530b  /* default 0x04 */
+#define OV5640_CIP_SH_TH_OFFSET_2 0x530c  /* default 0x06 */
+
+/* CMX Control [0x5380 ~ 0x538B] */
+#define OV5640_CMX1               0x5381  /* default 0x20 -> all 0x1e */
+#define OV5640_CMX2               0x5382  /* default 0x64 -> all 0x5b */
+#define OV5640_CMX3               0x5383  /* default 0x08 */
+#define OV5640_CMX4               0x5384  /* default 0x30 -> all 0x0a */
+#define OV5640_CMX5               0x5385  /* default 0x80 -> all 0x7e */
+#define OV5640_CMX6               0x5386  /* default 0xc0 -> all 0x88 */
+#define OV5640_CMX7               0x5387  /* default 0xa0 -> all 0x7c */
+#define OV5640_CMX8               0x5388  /* default 0x98 -> all 0x6c */
+#define OV5640_CMX9               0x5389  /* default 0x08 -> all 0x10 */
+#define OV5640_CMX_SIGN_0         0x538A  /* default 0x01 */
+#define OV5640_CMX_SIGN_1         0x538B  /* default 0x98 */
+
+/* Gamma Control [0x5480 ~ 0x5490] */
+#define OV5640_GAMMA_CTRL_00      0x5480  /* default 0x00 -> all 0x01 */
+#define OV5640_GAMMA_YST_00       0x5481  /* default 0x26 -> all 0x08 */
+#define OV5640_GAMMA_YST_01       0x5482  /* default 0x35 -> all 0x14 */
+
+#define OV5640_GAMMA_YST_02       0x5483  /* default 0x48 -> all 0x28 */
+#define OV5640_GAMMA_YST_03       0x5484  /* default 0x57 -> all 0x51 */
+#define OV5640_GAMMA_YST_04       0x5485  /* default 0x63 -> all 0x65 */
+#define OV5640_GAMMA_YST_05       0x5486  /* default 0x6e -> all 0x71 */
+
+#define OV5640_GAMMA_YST_06       0x5487  /* default 0x77 -> all 0x7d */
+#define OV5640_GAMMA_YST_07       0x5488  /* default 0x80 -> all 0x87 */
+#define OV5640_GAMMA_YST_08       0x5489  /* default 0x88 -> all 0x91 */
+#define OV5640_GAMMA_YST_09       0x548a  /* default 0x96 -> all 0x9a */
+#define OV5640_GAMMA_YST_0A       0x548b  /* default 0xa3 -> all 0xaa */
+#define OV5640_GAMMA_YST_0B       0x548c  /* default 0xaf -> all 0xb8 */
+#define OV5640_GAMMA_YST_0C       0x548d  /* default 0xc5 -> all 0xcd */
+#define OV5640_GAMMA_YST_0D       0x548e  /* default 0xd7 -> all 0xdd */
+#define OV5640_GAMMA_YST_0E       0x548f  /* default 0xe8 -> all 0xea */
+#define OV5640_GAMMA_YST_0F       0x5490  /* default 0x0f -> all 0x1d */
+
+/* SDE Control [0x5580 ~ 0x558C] */
+#define OV5640_SDE_CTRL_0         0x5580  /* default 0x00 -> all 0x02 */
+#define OV5640_SDE_CTRL_3         0x5583  /* default 0x40 */
+#define OV5640_SDE_CTRL_4         0x5584  /* default 0x40 -> all 0x10 */
+#define OV5640_SDE_CTRL_9         0x5589  /* default 0x01 -> all 0x10 */
+#define OV5640_SDE_CTRL_10        0x558a  /* default 0x01 -> all 0x00 */
+#define OV5640_SDE_CTRL_11        0x558b  /* default 0xff -> all 0xf8 */
+
+/* LENC Control [0x5800 ~ 0x5849] */
+#define OV5640_LENC_GMTRX_00      0x5800  /* default 0x10 -> all 0x23 */
+#define OV5640_LENC_GMTRX_01      0x5801  /* default 0x10 -> all 0x14 */
+#define OV5640_LENC_GMTRX_02      0x5802  /* default 0x10 -> all 0x0f */
+#define OV5640_LENC_GMTRX_03      0x5803  /* default 0x10 -> all 0x0f */
+#define OV5640_LENC_GMTRX_04      0x5804  /* default 0x10 -> all 0x12 */
+#define OV5640_LENC_GMTRX_05      0x5805  /* default 0x10 -> all 0x26 */
+#define OV5640_LENC_GMTRX_10      0x5806  /* default 0x10 -> all 0x0c */
+#define OV5640_LENC_GMTRX_11      0x5807  /* default 0x08 */
+#define OV5640_LENC_GMTRX_12      0x5808  /* default 0x08 -> all 0x05 */
+#define OV5640_LENC_GMTRX_13      0x5809  /* default 0x08 -> all 0x05 */
+#define OV5640_LENC_GMTRX_14      0x580a  /* default 0x08 -> all */
+#define OV5640_LENC_GMTRX_15      0x580b  /* default 0x10 -> all 0x0d */
+#define OV5640_LENC_GMTRX_20      0x580c  /* default 0x10 -> all 0x08 */
+#define OV5640_LENC_GMTRX_21      0x580d  /* default 0x08 -> all 0x03 */
+#define OV5640_LENC_GMTRX_22      0x580e  /* default 0x00 */
+#define OV5640_LENC_GMTRX_23      0x580f  /* default 0x00 */
+#define OV5640_LENC_GMTRX_24      0x5810  /* default 0x08 -> all 0x03 */
+#define OV5640_LENC_GMTRX_25      0x5811  /* default 0x10 -> all 0x09 */
+#define OV5640_LENC_GMTRX_30      0x5812  /* default 0x10 -> all 0x07 */
+#define OV5640_LENC_GMTRX_31      0x5813  /* default 0x08 -> all 0x03 */
+#define OV5640_LENC_GMTRX_32      0x5814  /* default 0x00 */
+#define OV5640_LENC_GMTRX_33      0x5815  /* default 0x00 -> all 0x01 */
+#define OV5640_LENC_GMTRX_34      0x5816  /* default 0x08 -> all 0x03 */
+#define OV5640_LENC_GMTRX_35      0x5817  /* default 0x10 -> all 0x08 */
+#define OV5640_LENC_GMTRX_40      0x5818  /* default 0x10 -> all 0x0d */
+#define OV5640_LENC_GMTRX_41      0x5819  /* default 0x08 */
+#define OV5640_LENC_GMTRX_42      0x581a  /* default 0x08 -> all 0x05 */
+#define OV5640_LENC_GMTRX_43      0x581b  /* default 0x08 -> all 0x06 */
+#define OV5640_LENC_GMTRX_44      0x581c  /* default 0x08 */
+#define OV5640_LENC_GMTRX_45      0x581d  /* default 0x10 -> all 0x0e */
+#define OV5640_LENC_GMTRX_50      0x581e  /* default 0x10 -> all 0x29 */
+#define OV5640_LENC_GMTRX_51      0x581f  /* default 0x10 -> all 0x17 */
+#define OV5640_LENC_GMTRX_52      0x5820  /* default 0x10 -> all 0x11 */
+#define OV5640_LENC_GMTRX_53      0x5821  /* default 0x10 -> all 0x11 */
+#define OV5640_LENC_GMTRX_54      0x5822  /* default 0x10 -> all 0x15 */
+#define OV5640_LENC_GMTRX_55      0x5823  /* default 0x10 -> all 0x28 */
+#define OV5640_LENC_BRMATRX_00    0x5824  /* default 0xaa -> all 0x46 */
+#define OV5640_LENC_BRMATRX_01    0x5825  /* default 0xaa -> all 0x26 */
+#define OV5640_LENC_BRMATRX_02    0x5826  /* default 0xaa -> all 0x08 */
+#define OV5640_LENC_BRMATRX_03    0x5827  /* default 0xaa -> all 0x26 */
+#define OV5640_LENC_BRMATRX_04    0x5828  /* default 0xaa -> all 0x64 */
+#define OV5640_LENC_BRMATRX_05    0x5829  /* default 0xaa -> all 0x26 */
+#define OV5640_LENC_BRMATRX_06    0x582a  /* default 0x99 -> all 0x24 */
+#define OV5640_LENC_BRMATRX_07    0x582b  /* default 0x99 -> all 0x22 */
+#define OV5640_LENC_BRMATRX_08    0x582c  /* default 0x99 -> all 0x24 */
+#define OV5640_LENC_BRMATRX_09    0x582d  /* default 0xaa -> all 0x24 */
+#define OV5640_LENC_BRMATRX_20    0x582e  /* default 0xaa -> all 0x06 */
+#define OV5640_LENC_BRMATRX_21    0x582f  /* default 0x99 -> all 0x22 */
+#define OV5640_LENC_BRMATRX_22    0x5830  /* default 0x88 -> all 0x40 */
+#define OV5640_LENC_BRMATRX_23    0x5831  /* default 0x99 -> all 0x42 */
+#define OV5640_LENC_BRMATRX_24    0x5832  /* default 0xaa -> all 0x24 */
+#define OV5640_LENC_BRMATRX_30    0x5833  /* default 0xaa -> all 0x26 */
+#define OV5640_LENC_BRMATRX_31    0x5834  /* default 0x99 -> all 0x24 */
+#define OV5640_LENC_BRMATRX_32    0x5835  /* default 0x99 -> all 0x22 */
+#define OV5640_LENC_BRMATRX_33    0x5836  /* default 0x99 -> all 0x22 */
+#define OV5640_LENC_BRMATRX_34    0x5837  /* default 0xaa -> all 0x26 */
+#define OV5640_LENC_BRMATRX_40    0x5838  /* default 0xaa -> all 0x44 */
+#define OV5640_LENC_BRMATRX_41    0x5839  /* default 0xaa -> all 0x24 */
+#define OV5640_LENC_BRMATRX_42    0x583a  /* default 0xaa -> all 0x26 */
+#define OV5640_LENC_BRMATRX_43    0x583b  /* default 0xaa -> all 0x28 */
+#define OV5640_LENC_BRMATRX_44    0x583c  /* default 0xaa -> all 0x42 */
+#define OV5640_LENC_BR_OFFSET     0x583d  /* default 0x88 -> all 0xce */
+#define SYSTEM_ROOT_DIVIDER 0x3108
+#define VCM_DEBUG_MODE_3600 0x3600
+#define VCM_DEBUG_MODE_3601 0x3601
+#define SYSTEM_CONTROL_302D 0x302D
+#define AEC_CTRL13 0x3A13
+#define AEC_GAIN_CEILING_00 0x3A18
+#define AEC_GAIN_CEILING_01 0x3A19
+#define OV5640_5060HZ_CTRL1 0x3C01
+#define OV5640_5060HZ_CTRL2 0x3C02
+#define OV5640_5060HZ_CTRL3 0x3C03
+#define OV5640_5060HZ_CTRL4 0x3C04
+#define OV5640_5060HZ_CTRL5 0x3C05
+#define LIGHT_METER1_THRESHOLD_00 0x3C06
+#define LIGHT_METER1_THRESHOLD_01 0x3C07
+
+
+static const ov5640_reg mode_1920x1080[] = {
+	{OV5640_SC_PLL_CTRL0, 0x10 | MIPI_MODE_8BIT },
+	{OV5640_SC_PLL_CTRL1, 0x11},
+	{OV5640_SC_PLL_CTRL2, 0x54},            /* default 0x69  PLL multipier */
+	{OV5640_SC_PLL_CTRL3, 0x03 | (1<<4) },  /* default 0x03  PLL divided by 2 */
+	{OV5640_MIPI_CTRL_00, 0x04},
+	{OV5640_MIPI_PCLK_PERIOD, 0x0a},
+	{FMT_CTRL_00, 0x32},
+	{OV5640_ISP_CTRL_00, 0xa7},
+	{OV5640_ISP_CTRL_01, 0x83},
+	{OV5640_ISP_MUX_CTRL, 0x00},    
+
+        /* Timing Control */
+	{OV5640_TIMING_HS_H, OV5640_ADDR_H(336) },
+	{OV5640_TIMING_HS_L, OV5640_ADDR_L(336) },
+	{OV5640_TIMING_VS_H, OV5640_ADDR_H(426) },
+	{OV5640_TIMING_VS_L, OV5640_ADDR_L(426) },
+	{OV5640_TIMING_HW_H, OV5640_ADDR_H(2287) },
+	{OV5640_TIMING_HW_L, OV5640_ADDR_L(2287) },
+	{OV5640_TIMING_VH_H, OV5640_ADDR_H(1529) },
+	{OV5640_TIMING_VH_L, OV5640_ADDR_L(1529) },
+	{OV5640_TIMING_DVPHO_H, OV5640_WIDTH_H(1920) }, //1936
+	{OV5640_TIMING_DVPHO_L, OV5640_WIDTH_L(1920) },
+	{OV5640_TIMING_DVPVO_H, OV5640_HEIGHT_H(1080) }, //1088
+	{OV5640_TIMING_DVPVO_L, OV5640_HEIGHT_L(1080) },
+	{OV5640_TIMING_HTS_H, OV5640_HTS_H(2500) },
+	{OV5640_TIMING_HTS_L, OV5640_HTS_L(2500) },
+	{OV5640_TIMING_VTS_H, OV5640_VTS_H(1120) },
+	{OV5640_TIMING_VTS_L, OV5640_VTS_L(1120) },
+	{OV5640_TIMING_HOFFSET_H, OV5640_H_OFFSET_H(15) }, // (2287-336-1936-1)/2
+	{OV5640_TIMING_HOFFSET_L, OV5640_H_OFFSET_L(15) },
+	{OV5640_TIMING_VOFFSET_H, OV5640_V_OFFSET_H(11) }, // (1529-426-1088-1)/2
+	{OV5640_TIMING_VOFFSET_L, OV5640_V_OFFSET_L(11) },
+	{OV5640_TIMING_X_INC, 0x11},
+	{OV5640_TIMING_Y_INC, 0x11},
+	{OV5640_TIMING_REG20, 0x40},
+	{OV5640_TIMING_REG21, 0},
+
+        /* magic registers */
+	{0x3612, 0x2b},
+	{0x3618, 0x04},
+	{0x3708, 0x64},
+	{0x3709, 0x12},
+	{0x370c, 0x00},
+
+	/* AEC/AGC Power Down Domain Control */
+	{OV5640_AEC_MAX_EXPO60_H, 0x04},
+	{OV5640_AEC_MAX_EXPO60_L, 0x60},
+	{OV5640_AEC_B50_STEP_H, 0x01},
+	{OV5640_AEC_B50_STEP_L, 0x50},
+	{OV5640_AEC_B60_STEP_H, 0x01},
+	{OV5640_AEC_B60_STEP_L, 0x18},
+	{OV5640_AEC_CTRL_0E, 0x03},
+	{OV5640_AEC_CTRL_0D, 0x04},
+	{OV5640_AEC_MAX_EXPO_H, 0x04},
+	{OV5640_AEC_MAX_EXPO_L, 0x60},
+	{OV5640_AEC_CTRL_13, 0x43},
+	{OV5640_AEC_GAIN_CEILING_0, 0x00},
+	{OV5640_AEC_GAIN_CEILING_1, 0xf8},
+	{OV5640_AEC_CTRL_0F, 0x30},
+	{OV5640_AEC_CTRL_10, 0x28},
+	{OV5640_AEC_CTRL_1B, 0x30},
+	{OV5640_AEC_CTRL_1E, 0x26},
+	{OV5640_AEC_CTRL_11, 0x60},
+	{OV5640_AEC_CTRL_1F, 0x14},
+
+	{OV5640_TABLE_END, 0x0000}
+};
+
+
+static const ov5640_reg table_mode_init[] = {
+
+
+        /* SCCB Control */
+	{OV5640_SCCB_SYSTEM_CTRL, 0x03},                   /* Clock from PLL */
+	{OV5640_SCCB_SCLK, 0x01},                          /* PCLK = pll_clki, SCLK = pll_clki/2 */
+
+        /* System Control */
+	{OV5640_SYSTEM_CTRL, 0x02 | SYSTEM_CTRL_SRST },    /* Software reset */
+	{OV5640_TABLE_WAIT_MS, 5},
+	{OV5640_SYSTEM_CTRL, 0x02 | SYSTEM_CTRL_PDOWN },   /* Software power down */
+	{OV5640_SYSTEM_MIPI_CTRL, 0x45}, //0x45
+	{OV5640_SYSTEM_CTRL_2D, 0x60},  /* magic values */
+	{OV5640_SYSTEM_CTRL_2E, 0x08},  /* magic values */
+
+
+        /* 50/60Hz detector control */
+	{OV5640_5060_CTRL_01, 0x34},
+	{OV5640_5060_CTRL_04, 0x28},
+	{OV5640_5060_CTRL_05, 0x98},
+	{OV5640_5060_THRESHOLD_1_H, 0x00},
+	{OV5640_5060_THRESHOLD_1_L, 0x07},
+	{OV5640_5060_THRESHOLD_2_H, 0x00},
+	{OV5640_5060_THRESHOLD_2_L, 0x1c},
+	{OV5640_5060_SAMPLE_NUM_H, 0x9c},
+	{OV5640_5060_SAMPLE_NUM_L, 0x40},
+
+        /* BLC Control */
+	{OV5640_BLC_CTRL_01, 0x02},
+	{OV5640_BLC_CTRL_04, 0x06},
+
+
+	{OV5640_TABLE_END, 0x0000},
+};
+
+
+
+static const ov5640_reg table_common_end[] = {
+// TODO: the rest here is actually standard for all modes.
+
+	/* AWB Control */
+	{OV5640_AWB_CTRL_00, 0xff},
+	{OV5640_AWB_CTRL_01, 0xf2},
+	{OV5640_AWB_CTRL_02, 0x00},
+	{OV5640_AWB_CTRL_03, 0x14},
+	{OV5640_AWB_CTRL_04, 0x25},
+	{OV5640_AWB_CTRL_05, 0x24},
+	{OV5640_AWB_CTRL_06, 0x09},
+	{OV5640_AWB_CTRL_07, 0x09},
+	{OV5640_AWB_CTRL_08, 0x09},
+	{OV5640_AWB_CTRL_09, 0x75},
+	{OV5640_AWB_CTRL_10, 0x54},
+	{OV5640_AWB_CTRL_11, 0xe0},
+	{OV5640_AWB_CTRL_12, 0xb2},
+	{OV5640_AWB_CTRL_13, 0x42},
+	{OV5640_AWB_CTRL_14, 0x3d},
+	{OV5640_AWB_CTRL_15, 0x56},
+	{OV5640_AWB_CTRL_16, 0x46},
+	{OV5640_AWB_CTRL_17, 0xf8},
+	{OV5640_AWB_CTRL_18, 0x04},
+	{OV5640_AWB_CTRL_19, 0x70},
+	{OV5640_AWB_CTRL_20, 0xf0},
+	{OV5640_AWB_CTRL_21, 0xf0},
+	{OV5640_AWB_CTRL_22, 0x03},
+	{OV5640_AWB_CTRL_23, 0x01},
+	{OV5640_AWB_CTRL_24, 0x04},
+	{OV5640_AWB_CTRL_25, 0x12},
+	{OV5640_AWB_CTRL_26, 0x04},
+	{OV5640_AWB_CTRL_27, 0x00},
+	{OV5640_AWB_CTRL_28, 0x06},
+	{OV5640_AWB_CTRL_29, 0x82},
+	{OV5640_AWB_CTRL_30, 0x38},
+
+	/* CMX Control */
+	{OV5640_CMX1, 0x1e},
+	{OV5640_CMX2, 0x5b},
+	{OV5640_CMX3, 0x08},
+	{OV5640_CMX4, 0x0a},
+	{OV5640_CMX5, 0x7e},
+	{OV5640_CMX6, 0x88},
+	{OV5640_CMX7, 0x7c},
+	{OV5640_CMX8, 0x6c},
+	{OV5640_CMX9, 0x10},
+	{OV5640_CMX_SIGN_0, 0x01},
+	{OV5640_CMX_SIGN_1, 0x98},
+
+	/* CIP Control */
+	{OV5640_CIP_SH_MT_THRES_1, 0x08},
+	{OV5640_CIP_SH_MT_THRES_2, 0x30},
+	{OV5640_CIP_SH_MT_OFFSET_1, 0x10},
+	{OV5640_CIP_SH_MT_OFFSET_2, 0x00},
+	{OV5640_CIP_DNS_THRES_1, 0x08},
+	{OV5640_CIP_DNS_THRES_2, 0x30},
+	{OV5640_CIP_DNS_OFFSET_1, 0x08},
+	{OV5640_CIP_DNS_OFFSET_2, 0x16},
+	{OV5640_CIP_SH_TH_THRES_1, 0x08},
+	{OV5640_CIP_SH_TH_THRES_2, 0x30},
+	{OV5640_CIP_SH_TH_OFFSET_1, 0x04},
+	{OV5640_CIP_SH_TH_OFFSET_2, 0x06},
+
+	/* Gamma Control */
+	{OV5640_GAMMA_CTRL_00, 0x01},
+	{OV5640_GAMMA_YST_00, 0x08},
+	{OV5640_GAMMA_YST_01, 0x14},
+	{OV5640_GAMMA_YST_02, 0x28},
+	{OV5640_GAMMA_YST_03, 0x51},
+	{OV5640_GAMMA_YST_04, 0x65},
+	{OV5640_GAMMA_YST_05, 0x71},
+	{OV5640_GAMMA_YST_06, 0x7d},
+	{OV5640_GAMMA_YST_07, 0x87},
+	{OV5640_GAMMA_YST_08, 0x91},
+	{OV5640_GAMMA_YST_09, 0x9a},
+	{OV5640_GAMMA_YST_0A, 0xaa},
+	{OV5640_GAMMA_YST_0B, 0xb8},
+	{OV5640_GAMMA_YST_0C, 0xcd},
+	{OV5640_GAMMA_YST_0D, 0xdd},
+	{OV5640_GAMMA_YST_0E, 0xea},
+	{OV5640_GAMMA_YST_0F, 0x1d},
+
+	/* SDE Control */
+	{OV5640_SDE_CTRL_0, 0x02},
+	{OV5640_SDE_CTRL_3, 0x40},
+	{OV5640_SDE_CTRL_4, 0x10},
+	{OV5640_SDE_CTRL_9, 0x10},
+	{OV5640_SDE_CTRL_10, 0x00},
+	{OV5640_SDE_CTRL_11, 0xf8},
+
+	/* LENC Control */
+	{OV5640_LENC_GMTRX_00, 0x23},
+	{OV5640_LENC_GMTRX_01, 0x14},
+	{OV5640_LENC_GMTRX_02, 0x0f},
+	{OV5640_LENC_GMTRX_03, 0x0f},
+	{OV5640_LENC_GMTRX_04, 0x12},
+	{OV5640_LENC_GMTRX_05, 0x26},
+	{OV5640_LENC_GMTRX_10, 0x0c},
+	{OV5640_LENC_GMTRX_11, 0x08},
+	{OV5640_LENC_GMTRX_12, 0x05},
+	{OV5640_LENC_GMTRX_13, 0x05},
+	{OV5640_LENC_GMTRX_14, 0x08},
+	{OV5640_LENC_GMTRX_15, 0x0d},
+	{OV5640_LENC_GMTRX_20, 0x08},
+	{OV5640_LENC_GMTRX_21, 0x03},
+	{OV5640_LENC_GMTRX_22, 0x00},
+	{OV5640_LENC_GMTRX_23, 0x00},
+	{OV5640_LENC_GMTRX_24, 0x03},
+	{OV5640_LENC_GMTRX_25, 0x09},
+	{OV5640_LENC_GMTRX_30, 0x07},
+	{OV5640_LENC_GMTRX_31, 0x03},
+	{OV5640_LENC_GMTRX_32, 0x00},
+	{OV5640_LENC_GMTRX_33, 0x01},
+	{OV5640_LENC_GMTRX_34, 0x03},
+	{OV5640_LENC_GMTRX_35, 0x08},
+	{OV5640_LENC_GMTRX_40, 0x0d},
+	{OV5640_LENC_GMTRX_41, 0x08},
+	{OV5640_LENC_GMTRX_42, 0x05},
+	{OV5640_LENC_GMTRX_43, 0x06},
+	{OV5640_LENC_GMTRX_44, 0x08},
+	{OV5640_LENC_GMTRX_45, 0x0e},
+	{OV5640_LENC_GMTRX_50, 0x29},
+	{OV5640_LENC_GMTRX_51, 0x17},
+	{OV5640_LENC_GMTRX_52, 0x11},
+	{OV5640_LENC_GMTRX_53, 0x11},
+	{OV5640_LENC_GMTRX_54, 0x15},
+	{OV5640_LENC_GMTRX_55, 0x28},
+	{OV5640_LENC_BRMATRX_00, 0x46},
+	{OV5640_LENC_BRMATRX_01, 0x26},
+	{OV5640_LENC_BRMATRX_02, 0x08},
+	{OV5640_LENC_BRMATRX_03, 0x26},
+	{OV5640_LENC_BRMATRX_04, 0x64},
+	{OV5640_LENC_BRMATRX_05, 0x26},
+	{OV5640_LENC_BRMATRX_06, 0x24},
+	{OV5640_LENC_BRMATRX_07, 0x22},
+	{OV5640_LENC_BRMATRX_08, 0x24},
+	{OV5640_LENC_BRMATRX_09, 0x24},
+	{OV5640_LENC_BRMATRX_20, 0x06},
+	{OV5640_LENC_BRMATRX_21, 0x22},
+	{OV5640_LENC_BRMATRX_22, 0x40},
+	{OV5640_LENC_BRMATRX_23, 0x42},
+	{OV5640_LENC_BRMATRX_24, 0x24},
+	{OV5640_LENC_BRMATRX_30, 0x26},
+	{OV5640_LENC_BRMATRX_31, 0x24},
+	{OV5640_LENC_BRMATRX_32, 0x22},
+	{OV5640_LENC_BRMATRX_33, 0x22},
+	{OV5640_LENC_BRMATRX_34, 0x26},
+	{OV5640_LENC_BRMATRX_40, 0x44},
+	{OV5640_LENC_BRMATRX_41, 0x24},
+	{OV5640_LENC_BRMATRX_42, 0x26},
+	{OV5640_LENC_BRMATRX_43, 0x28},
+	{OV5640_LENC_BRMATRX_44, 0x42},
+	{OV5640_LENC_BR_OFFSET, 0xce},
+
+//	{0x5025, 0x00},
+//	{0x3a0f, 0x30},
+//	{0x3a10, 0x28},
+//	{0x3a1b, 0x30},
+//	{0x3a1e, 0x26},
+//	{0x3a11, 0x60},
+//	{0x3a1f, 0x14},
+
+       /* magic registers */
+	{0x3620, 0x52},
+	{0x3621, 0xe0},
+	{0x3622, 0x01},
+	{0x3630, 0x36}, 
+	{0x3631, 0x0e},
+	{0x3632, 0xe2},
+	{0x3633, 0x12},
+	{0x3634, 0x40},
+	{0x3635, 0x13},
+	{0x3636, 0x03},
+	{0x3703, 0x5a},
+	{0x3704, 0xa0},
+	{0x3705, 0x1a},
+	{0x370b, 0x60},
+	{0x3715, 0x78},
+	{0x3717, 0x01},
+	{0x371b, 0x20},
+	{0x3731, 0x12},
+	{0x3901, 0x0a},
+	{0x3905, 0x02},
+        {0x3906, 0x10},
+	{0x471c, 0x50},
+
+	{OV5640_SYSTEM_CTRL, 0x02},
+	{OV5640_TABLE_END, 0x0000},
+};
+
+static const ov5640_reg tp_colorbars[] = {
+	{OV5640_ISP_TEST, ISP_TEST_EN | ISP_TEST_00 },
+	{OV5640_ISP_DEBUG_3E, 0x00},
+	{OV5640_ISP_DEBUG_46, 0x01},
+//	{OV5640_TABLE_WAIT_MS, OV5640_WAIT_MS},
+	{OV5640_TABLE_END, 0x0000}
+};
+
+
+enum {
+	OV5640_MODE_1920x1080,
+	OV5640_MODE_TEST_PATTERN
+};
+
+static const ov5640_reg *mode_table[] = {
+	[OV5640_MODE_1920x1080] = mode_1920x1080,
+	[OV5640_MODE_TEST_PATTERN] = tp_colorbars,
+};
+
+static const int ov5640_15fps[] = {
+	15,
+};
+
+static const int ov5640_30fps[] = {
+	30,
+};
+
+static const int ov5640_45fps[] = {
+	45,
+};
+
+
+static const int ov5640_90fps[] = {
+	90,
+};
+
+static const struct camera_common_frmfmt ov5640_frmfmt[] = {
+	{{1920, 1080},	ov5640_30fps,	1, 0,	OV5640_MODE_1920x1080},
+};
+#endif  /* __OV5640_TABLES__ */
+
diff --git a/nvidia/include/media/ov5640.h b/nvidia/include/media/ov5640.h
new file mode 100644
index 000000000000..35587d142189
--- /dev/null
+++ b/nvidia/include/media/ov5640.h
@@ -0,0 +1,109 @@
+/*
+ * file based on ov5693.h
+ * Copyright (c) 2013-2015, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __OV5640_H__
+#define __OV5640_H__
+
+#include <media/nvc.h>
+#include <uapi/media/nvc_image.h>
+#include <uapi/media/ov5640.h>
+
+#define OV5640_INVALID_COARSE_TIME  -1
+
+#define OV5640_EEPROM_ADDRESS		0x50
+#define OV5640_EEPROM_SIZE		1024
+#define OV5640_EEPROM_STR_SIZE		(OV5640_EEPROM_SIZE * 2)
+#define OV5640_EEPROM_BLOCK_SIZE	(1 << 8)
+#define OV5640_EEPROM_NUM_BLOCKS \
+	(OV5640_EEPROM_SIZE / OV5640_EEPROM_BLOCK_SIZE)
+
+#define OV5640_OTP_LOAD_CTRL_ADDR	0x3D81
+#define OV5640_OTP_BANK_SELECT_ADDR	0x3D84
+#define OV5640_OTP_BANK_START_ADDR	0x3D00
+#define OV5640_OTP_BANK_END_ADDR	0x3D0F
+#define OV5640_OTP_NUM_BANKS		(32)
+#define OV5640_OTP_BANK_SIZE \
+	 (OV5640_OTP_BANK_END_ADDR - OV5640_OTP_BANK_START_ADDR + 1)
+#define OV5640_OTP_SIZE \
+	 (OV5640_OTP_BANK_SIZE * OV5640_OTP_NUM_BANKS)
+#define OV5640_OTP_STR_SIZE (OV5640_OTP_SIZE * 2)
+
+#define OV5640_FUSE_ID_OTP_START_ADDR	0x3D00
+#define OV5640_FUSE_ID_OTP_BANK	0
+#define OV5640_FUSE_ID_SIZE		8
+#define OV5640_FUSE_ID_STR_SIZE	(OV5640_FUSE_ID_SIZE * 2)
+
+#define OV5640_FRAME_LENGTH_ADDR_MSB		0x380E
+#define OV5640_FRAME_LENGTH_ADDR_LSB		0x380F
+#define OV5640_COARSE_TIME_ADDR_1		0x3500
+#define OV5640_COARSE_TIME_ADDR_2		0x3501
+#define OV5640_COARSE_TIME_ADDR_3		0x3502
+#define OV5640_COARSE_TIME_SHORT_ADDR_1	0x3506
+#define OV5640_COARSE_TIME_SHORT_ADDR_2	0x3507
+#define OV5640_COARSE_TIME_SHORT_ADDR_3	0x3508
+#define OV5640_GAIN_ADDR_MSB			0x350A
+#define OV5640_GAIN_ADDR_LSB			0x350B
+#define OV5640_GROUP_HOLD_ADDR			0x3208
+#define OV5640_TIMING_REG20			0x3820
+#define VERTICAL_FLIP				(0x3 << 1)
+#define OV5640_TIMING_REG21			0x3821
+#define HORIZONTAL_MIRROR_MASK			(0x3 << 1)
+
+/* See notes in the nvc.h file on the GPIO usage */
+enum ov5640_gpio_type {
+	OV5640_GPIO_TYPE_PWRDN = 0,
+	OV5640_GPIO_TYPE_RESET,
+};
+
+struct ov5640_eeprom_data {
+	struct i2c_client *i2c_client;
+	struct i2c_adapter *adap;
+	struct i2c_board_info brd;
+	struct regmap *regmap;
+};
+
+struct ov5640_power_rail {
+	struct regulator *dvdd;
+	struct regulator *avdd;
+	struct regulator *dovdd;
+};
+
+struct ov5640_regulators {
+	const char *avdd;
+	const char *dvdd;
+	const char *dovdd;
+};
+
+struct ov5640_platform_data {
+	unsigned cfg;
+	unsigned num;
+	const char *dev_name;
+	unsigned gpio_count; /* see nvc.h GPIO notes */
+	struct nvc_gpio_pdata *gpio; /* see nvc.h GPIO notes */
+	struct nvc_imager_static_nvc *static_info;
+	bool use_vcm_vdd;
+	int (*probe_clock)(unsigned long);
+	int (*power_on)(struct ov5640_power_rail *);
+	int (*power_off)(struct ov5640_power_rail *);
+	const char *mclk_name;
+	struct nvc_imager_cap *cap;
+	struct ov5640_regulators regulators;
+	bool has_eeprom;
+	bool use_cam_gpio;
+};
+
+#endif  /* __OV5640_H__ */
diff --git a/nvidia/include/uapi/media/ov5640.h b/nvidia/include/uapi/media/ov5640.h
new file mode 100644
index 000000000000..d8af80c00887
--- /dev/null
+++ b/nvidia/include/uapi/media/ov5640.h
@@ -0,0 +1,93 @@
+/*
+ * file based on ov5693.h
+ * Copyright (c) 2013-2015, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __UAPI_OV5640_H__
+#define __UAPI_OV5640_H__
+
+#include <media/nvc.h>
+#include "nvc_image.h"
+
+#define OV5640_IOCTL_SET_MODE               _IOW('o', 1, struct ov5640_mode)
+#define OV5640_IOCTL_SET_FRAME_LENGTH       _IOW('o', 2, __u32)
+#define OV5640_IOCTL_SET_COARSE_TIME        _IOW('o', 3, __u32)
+#define OV5640_IOCTL_SET_GAIN               _IOW('o', 4, __u16)
+#define OV5640_IOCTL_GET_STATUS             _IOR('o', 5, __u8)
+#define OV5640_IOCTL_SET_BINNING            _IOW('o', 6, __u8)
+#define OV5640_IOCTL_TEST_PATTERN           _IOW('o', 7, \
+						 enum ov5640_test_pattern)
+#define OV5640_IOCTL_SET_GROUP_HOLD         _IOW('o', 8, struct ov5640_ae)
+/* IOCTL to set the operating mode of camera.
+ * This can be either stereo , leftOnly or rightOnly */
+#define OV5640_IOCTL_SET_CAMERA_MODE        _IOW('o', 10, __u32)
+#define OV5640_IOCTL_SYNC_SENSORS           _IOW('o', 11, __u32)
+#define OV5640_IOCTL_GET_FUSEID             _IOR('o', 12, struct nvc_fuseid)
+#define OV5640_IOCTL_SET_HDR_COARSE_TIME    _IOW('o', 13, struct ov5640_hdr)
+#define OV5640_IOCTL_READ_OTP_BANK          _IOWR('o', 14, \
+						struct ov5640_otp_bank)
+#define OV5640_IOCTL_SET_CAL_DATA           _IOW('o', 15, \
+						struct ov5640_cal_data)
+#define OV5640_IOCTL_GET_EEPROM_DATA        _IOR('o', 20, __u8 *)
+#define OV5640_IOCTL_SET_EEPROM_DATA        _IOW('o', 21, __u8 *)
+#define OV5640_IOCTL_GET_CAPS               _IOR('o', 22, struct nvc_imager_cap)
+#define OV5640_IOCTL_SET_POWER              _IOW('o', 23, __u32)
+
+struct ov5640_mode {
+	int res_x;
+	int res_y;
+	int fps;
+	__u32 frame_length;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u16 gain;
+	__u8 hdr_en;
+};
+
+struct ov5640_ae {
+	__u32 frame_length;
+	__u8  frame_length_enable;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u8  coarse_time_enable;
+	__s32 gain;
+	__u8  gain_enable;
+};
+
+struct ov5640_fuseid {
+	__u32 size;
+	__u8  id[16];
+};
+
+struct ov5640_hdr {
+	__u32 coarse_time_long;
+	__u32 coarse_time_short;
+};
+
+struct ov5640_otp_bank {
+	__u32 id;
+	__u8  buf[16];
+};
+
+struct ov5640_cal_data {
+	int loaded;
+	int rg_ratio;
+	int bg_ratio;
+	int rg_ratio_typical;
+	int bg_ratio_typical;
+	__u8 lenc[62];
+};
+
+#endif  /* __UAPI_OV5640_H__ */
-- 
2.25.1

